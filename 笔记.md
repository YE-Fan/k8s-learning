## 账本验证问题（不可篡改）

账本： 

![image-20220217214510259](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202172145313.png)

账本在每个人电脑里有一份，某个人篡改了，账本如何验证？







可能方案：

1. 逐个核对账本记录，少数服从多数。谁的不一样， 谁的就被篡改过了
   - 问题：一本账本还好，账本很多的情况下，核对效率太低了

哈希方案：

对整个账本进行hash，每个人只比对hash值

![image-20220217214526979](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202172145027.png)

由此产生了区块的概念

![image-20220217214550058](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202172145098.png)

显然，一个区块就是上一次的hash加上这一次的交易记录





第二个账本的hash，在第一个账本hash的基础上进行hash，这样就只需要对比第二次账本的hash就够了

![image-20220217214159888](C:/Users/admin/AppData/Roaming/Typora/typora-user-images/image-20220217214159888.png)



如下，每次的hash都在前一次的基础上，形成了一条链

![image-20220217214427137](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202172144185.png)



## 账户所有权问题（隐私性和安全性）

![image-20220218214304794](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182143853.png)

中心机构（银行） 验证账户密码，或者人脸识别啊之类的。

比特币是点对点交易，没有这些中心机构。

如下一笔转账

![image-20220218214353715](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182143746.png)

有私钥，我就拥有这个地址（账号）

![image-20220218214458322](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182144368.png)

运算（私钥）能得到地址。

证明所有权的问题，就变成了如何不泄露私钥情况下，证明我对地址的拥有权。

通过非对称加密进行。

![image-20220218214754482](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182147521.png)

第一步计算摘要要在安全的环境下做，避免泄露私钥，通常是在离线环境下。

这两步操作用代码表示如下

![image-20220218214849428](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182148465.png)

在某台机器上发生了交易，就会广播给其它机器。其它机器进行验证

![image-20220218215022941](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182150012.png)

验证方法如下

用地址对签名进行解密，得到摘要

![image-20220218215108765](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182151810.png)



即 **地址和私钥是一对 公/私钥。**

**公钥加密私钥解密，私钥加密公钥解密。**

**我能用私钥加密（签名），所以对应私钥的这个地址属于我，我用私钥签名的交易记录，别人就能用我分发的公钥（地址）来验证（解密）。**

由此保证了隐私性和安全性

- 隐私性： 因为别人只知道我的地址（公钥），里面没有保护任何个人信息。
- 安全性：非对称加密懂得都懂，只要私钥不泄露，别人什么也干不了，不像银行想冻结你就冻结你。



```
sign(交易记录hash值, 私钥) = 数字签名
verify(签名, 公钥) =  交易记录hash值
```



## 记账（挖矿）

![image-20220218220643982](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182206031.png)

计算hash打包成区块是要消耗资源的，那么为什么我们愿意去计算。比特币就发明了这样一个机制，你这个节点记账了，就给你发奖励（比特币）。

![image-20220218220729544](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182207591.png)

### 记账权

有奖励就会导致大家争相记账。如果一起记账，就可能造成大家计算的hash值不同。那么谁来记账呢？

因此需要一个规则来决定让谁记账：

![image-20220218221054668](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182210727.png)

 第二点就是所谓的挖矿：解决密码学难题，因为这个解决难题的过程是有随机性的，就像挖矿一样，指不定谁就挖到金矿了。



#### POW工作量证明：

最基本的记账就是 Hash(上一次hash值，此次交易记录集合) =  65465zasdsad

现在给它加入密码学难题，hash碰撞

比如说要求 Hash(上一次hash值，此次交易记录集合，随机数) =  000065465zasdsad

计算得到的hash值必须以4个0开头。

谁能先得到这个随机数，谁就获得了这次的记账权。



其中交易记录集合是如下：

![image-20220218221748805](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182217858.png)

一方面收集未记录的交易并验证，一方面添加一笔给自己转账的交易（挖矿奖励）。

所以只要我能记账成功，就相当于是得到了一笔挖矿奖励。



工作量证明的计算量：

假如这次的块我要求要18个0开头。

![image-20220218222055096](https://raw.githubusercontent.com/YE-Fan/k8s-learning/main/imgs/202202182220157.png)

那么就需要  16的18次方次猜测，才能猜到这个随机数。

16^18，即如果一位是0，那么在16进制下，最多需要猜16次，18位是0，所以是1/16 * 1/16 * ......1*16的概率。



**为什么叫工作量证明，因为我能碰撞出这个hash值，必然进行了很多次碰撞。**